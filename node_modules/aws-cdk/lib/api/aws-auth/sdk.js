"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK = void 0;
const AWS = require("aws-sdk");
const logging_1 = require("../../logging");
const functions_1 = require("../../util/functions");
const account_cache_1 = require("./account-cache");
/**
 * Base functionality of SDK without credential fetching
 */
class SDK {
    constructor(credentials, region, httpOptions = {}) {
        this.credentials = credentials;
        /**
         * Default retry options for SDK clients.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        /**
         * The more generous retry policy for CloudFormation, which has a 1 TPM limit on certain APIs,
         * which are abundantly used for deployment tracking, ...
         *
         * So we're allowing way more retries, but waiting a bit more.
         */
        this.cloudFormationRetryOptions = { maxRetries: 10, retryDelayOptions: { base: 1000 } };
        this.config = {
            ...httpOptions,
            ...this.retryOptions,
            credentials,
            region,
            logger: { log: (...messages) => messages.forEach(m => logging_1.trace('%s', m)) },
        };
        this.currentRegion = region;
    }
    cloudFormation() {
        return wrapServiceErrorHandling(new AWS.CloudFormation({
            ...this.config,
            ...this.cloudFormationRetryOptions,
        }));
    }
    ec2() {
        return wrapServiceErrorHandling(new AWS.EC2(this.config));
    }
    ssm() {
        return wrapServiceErrorHandling(new AWS.SSM(this.config));
    }
    s3() {
        return wrapServiceErrorHandling(new AWS.S3(this.config));
    }
    route53() {
        return wrapServiceErrorHandling(new AWS.Route53(this.config));
    }
    ecr() {
        return wrapServiceErrorHandling(new AWS.ECR(this.config));
    }
    elbv2() {
        return wrapServiceErrorHandling(new AWS.ELBv2(this.config));
    }
    async currentAccount() {
        return functions_1.cached(this, CURRENT_ACCOUNT_KEY, () => SDK.accountCache.fetch(this.credentials.accessKeyId, async () => {
            // if we don't have one, resolve from STS and store in cache.
            logging_1.debug('Looking up default account ID from STS');
            const result = await new AWS.STS(this.config).getCallerIdentity().promise();
            const accountId = result.Account;
            const partition = result.Arn.split(':')[1];
            if (!accountId) {
                throw new Error('STS didn\'t return an account ID');
            }
            logging_1.debug('Default account ID:', accountId);
            return { accountId, partition };
        }));
    }
    /**
     * Return the current credentials
     *
     * Don't use -- only used to write tests around assuming roles.
     */
    async currentCredentials() {
        await this.credentials.getPromise();
        return this.credentials;
    }
}
exports.SDK = SDK;
SDK.accountCache = new account_cache_1.AccountAccessKeyCache();
/**
 * Return a wrapping object for the underlying service object
 *
 * Responds to failures in the underlying service calls, in two different
 * ways:
 *
 * - When errors are encountered, log the failing call and the error that
 *   it triggered (at debug level). This is necessary because the lack of
 *   stack traces in NodeJS otherwise makes it very hard to suss out where
 *   a certain AWS error occurred.
 * - The JS SDK has a funny business of wrapping any credential-based error
 *   in a super-generic (and in our case wrong) exception. If we then use a
 *   'ChainableTemporaryCredentials' and the target role doesn't exist,
 *   the error message that shows up by default is super misleading
 *   (https://github.com/aws/aws-sdk-js/issues/3272). We can fix this because
 *   the exception contains the "inner exception", so we unwrap and throw
 *   the correct error ("cannot assume role").
 *
 * The wrapping business below is slightly more complicated than you'd think
 * because we must hook into the `promise()` method of the object that's being
 * returned from the methods of the object that we wrap, so there's two
 * levels of wrapping going on, and also some exceptions to the wrapping magic.
 */
function wrapServiceErrorHandling(serviceObject) {
    const classObject = serviceObject.constructor.prototype;
    return new Proxy(serviceObject, {
        get(obj, prop) {
            const real = obj[prop];
            // Things we don't want to intercept:
            // - Anything that's not a function.
            // - 'constructor', s3.upload() will use this to do some magic and we need the underlying constructor.
            // - Any method that's not on the service class (do not intercept 'makeRequest' and other helpers).
            if (prop === 'constructor' || !classObject.hasOwnProperty(prop) || !isFunction(real)) {
                return real;
            }
            // NOTE: This must be a function() and not an () => {
            // because I need 'this' to be dynamically bound and not statically bound.
            // If your linter complains don't listen to it!
            return function () {
                // Call the underlying function. If it returns an object with a promise()
                // method on it, wrap that 'promise' method.
                const args = [].slice.call(arguments, 0);
                const response = real.apply(this, args);
                // Don't intercept unless the return value is an object with a '.promise()' method.
                if (typeof response !== 'object' || !response) {
                    return response;
                }
                if (!('promise' in response)) {
                    return response;
                }
                // Return an object with the promise method replaced with a wrapper which will
                // do additional things to errors.
                return Object.assign(Object.create(response), {
                    promise() {
                        return response.promise().catch((e) => {
                            e = makeDetailedException(e);
                            logging_1.debug(`Call failed: ${prop}(${JSON.stringify(args[0])}) => ${e.message}`);
                            return Promise.reject(e); // Re-'throw' the new error
                        });
                    },
                });
            };
        },
    });
}
const CURRENT_ACCOUNT_KEY = Symbol('current_account_key');
function isFunction(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Extract a more detailed error out of a generic error if we can
 */
function makeDetailedException(e) {
    // This is the super-generic "something's wrong" error that the JS SDK wraps other errors in.
    // https://github.com/aws/aws-sdk-js/blob/f0ac2e53457c7512883d0677013eacaad6cd8a19/lib/event_listeners.js#L84
    if (typeof e.message === 'string' && e.message.startsWith('Missing credentials in config')) {
        const original = e.originalError;
        if (original) {
            // When the SDK does a 'util.copy', they lose the Error-ness of the inner error
            // (they copy the Error's properties into a plain object) so make it an Error object again.
            e = Object.assign(new Error(), original);
        }
    }
    // At this point, the error might still be a generic "ChainableTemporaryCredentials failed"
    // error which wraps the REAL error (AssumeRole failed). We're going to replace the error
    // message with one that's more likely to help users, and tell them the most probable
    // fix (bootstrapping). The underlying service call failure will be appended below.
    if (e.message === 'Could not load credentials from ChainableTemporaryCredentials') {
        e.message = 'Could not assume role in target account (did you bootstrap the environment with the right \'--trust\'s?)';
    }
    // Replace the message on this error with a concatenation of all inner error messages.
    // Must more clear what's going on that way.
    e.message = allChainedExceptionMessages(e);
    return e;
}
/**
 * Return the concatenated message of all exceptions in the AWS exception chain
 */
function allChainedExceptionMessages(e) {
    const ret = new Array();
    while (e) {
        ret.push(e.message);
        e = e.originalError;
    }
    return ret.join(': ');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUUvQiwyQ0FBNkM7QUFDN0Msb0RBQThDO0FBQzlDLG1EQUF3RDtBQThCeEQ7O0dBRUc7QUFDSCxNQUFhLEdBQUc7SUFvQmQsWUFBNkIsV0FBNEIsRUFBRSxNQUFjLEVBQUUsY0FBb0MsRUFBRTtRQUFwRixnQkFBVyxHQUFYLFdBQVcsQ0FBaUI7UUFiekQ7O1dBRUc7UUFDYyxpQkFBWSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBRXBGOzs7OztXQUtHO1FBQ2MsK0JBQTBCLEdBQUcsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUssRUFBRSxFQUFFLENBQUM7UUFHbkcsSUFBSSxDQUFDLE1BQU0sR0FBRztZQUNaLEdBQUcsV0FBVztZQUNkLEdBQUcsSUFBSSxDQUFDLFlBQVk7WUFDcEIsV0FBVztZQUNYLE1BQU07WUFDTixNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGVBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUN4RSxDQUFDO1FBQ0YsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUM7SUFDOUIsQ0FBQztJQUVNLGNBQWM7UUFDbkIsT0FBTyx3QkFBd0IsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUM7WUFDckQsR0FBRyxJQUFJLENBQUMsTUFBTTtZQUNkLEdBQUcsSUFBSSxDQUFDLDBCQUEwQjtTQUNuQyxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7SUFFTSxHQUFHO1FBQ1IsT0FBTyx3QkFBd0Is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Q0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHR5cGUgeyBDb25maWd1cmF0aW9uT3B0aW9ucyB9IGZyb20gJ2F3cy1zZGsvbGliL2NvbmZpZy1iYXNlJztcbmltcG9ydCB7IGRlYnVnLCB0cmFjZSB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgY2FjaGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQWNjb3VudEFjY2Vzc0tleUNhY2hlIH0gZnJvbSAnLi9hY2NvdW50LWNhY2hlJztcbmltcG9ydCB7IEFjY291bnQgfSBmcm9tICcuL3Nkay1wcm92aWRlcic7XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIElTREsge1xuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdFJlZ2lvbigpYCBvbiBTZGtQcm92aWRlciB3aGljaFxuICAgKiByZXByZXNlbnRzIHRoZSByZWdpb24gY29uZmlndXJlZCBpbiB0aGUgZGVmYXVsdCBjb25maWcpLlxuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudFJlZ2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQWNjb3VudCB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdEFjY291bnQoKWAgb24gU2RrUHJvdmlkZXIgd2hpY2hcbiAgICogcmVwcmVzZW50cyB0aGUgYWNjb3VudCBhdmFpbGFibGUgYnkgdXNpbmcgZGVmYXVsdCBjcmVkZW50aWFscykuXG4gICAqL1xuICBjdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQ+O1xuXG4gIGNsb3VkRm9ybWF0aW9uKCk6IEFXUy5DbG91ZEZvcm1hdGlvbjtcbiAgZWMyKCk6IEFXUy5FQzI7XG4gIHNzbSgpOiBBV1MuU1NNO1xuICBzMygpOiBBV1MuUzM7XG4gIHJvdXRlNTMoKTogQVdTLlJvdXRlNTM7XG4gIGVjcigpOiBBV1MuRUNSO1xuICBlbGJ2MigpOiBBV1MuRUxCdjI7XG59XG5cbi8qKlxuICogQmFzZSBmdW5jdGlvbmFsaXR5IG9mIFNESyB3aXRob3V0IGNyZWRlbnRpYWwgZmV0Y2hpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFNESyBpbXBsZW1lbnRzIElTREsge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBhY2NvdW50Q2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKCk7XG5cbiAgcHVibGljIHJlYWRvbmx5IGN1cnJlbnRSZWdpb246IHN0cmluZztcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogQ29uZmlndXJhdGlvbk9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmV0cnkgb3B0aW9ucyBmb3IgU0RLIGNsaWVudHMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJldHJ5T3B0aW9ucyA9IHsgbWF4UmV0cmllczogNiwgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMzAwIH0gfTtcblxuICAvKipcbiAgICogVGhlIG1vcmUgZ2VuZXJvdXMgcmV0cnkgcG9saWN5IGZvciBDbG91ZEZvcm1hdGlvbiwgd2hpY2ggaGFzIGEgMSBUUE0gbGltaXQgb24gY2VydGFpbiBBUElzLFxuICAgKiB3aGljaCBhcmUgYWJ1bmRhbnRseSB1c2VkIGZvciBkZXBsb3ltZW50IHRyYWNraW5nLCAuLi5cbiAgICpcbiAgICogU28gd2UncmUgYWxsb3dpbmcgd2F5IG1vcmUgcmV0cmllcywgYnV0IHdhaXRpbmcgYSBiaXQgbW9yZS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgY2xvdWRGb3JtYXRpb25SZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDEwLCByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAxXzAwMCB9IH07XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjcmVkZW50aWFsczogQVdTLkNyZWRlbnRpYWxzLCByZWdpb246IHN0cmluZywgaHR0cE9wdGlvbnM6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLmh0dHBPcHRpb25zLFxuICAgICAgLi4udGhpcy5yZXRyeU9wdGlvbnMsXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHJlZ2lvbixcbiAgICAgIGxvZ2dlcjogeyBsb2c6ICguLi5tZXNzYWdlcykgPT4gbWVzc2FnZXMuZm9yRWFjaChtID0+IHRyYWNlKCclcycsIG0pKSB9LFxuICAgIH07XG4gICAgdGhpcy5jdXJyZW50UmVnaW9uID0gcmVnaW9uO1xuICB9XG5cbiAgcHVibGljIGNsb3VkRm9ybWF0aW9uKCk6IEFXUy5DbG91ZEZvcm1hdGlvbiB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkNsb3VkRm9ybWF0aW9uKHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4udGhpcy5jbG91ZEZvcm1hdGlvblJldHJ5T3B0aW9ucyxcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgZWMyKCk6IEFXUy5FQzIge1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5FQzIodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBzc20oKTogQVdTLlNTTSB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLlNTTSh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIHMzKCk6IEFXUy5TMyB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLlMzKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgcm91dGU1MygpOiBBV1MuUm91dGU1MyB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLlJvdXRlNTModGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBlY3IoKTogQVdTLkVDUiB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkVDUih0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGVsYnYyKCk6IEFXUy5FTEJ2MiB7XG4gICAgcmV0dXJuIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkVMQnYyKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3VycmVudEFjY291bnQoKTogUHJvbWlzZTxBY2NvdW50PiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLCBDVVJSRU5UX0FDQ09VTlRfS0VZLCAoKSA9PiBTREsuYWNjb3VudENhY2hlLmZldGNoKHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgb25lLCByZXNvbHZlIGZyb20gU1RTIGFuZCBzdG9yZSBpbiBjYWNoZS5cbiAgICAgIGRlYnVnKCdMb29raW5nIHVwIGRlZmF1bHQgYWNjb3VudCBJRCBmcm9tIFNUUycpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IEFXUy5TVFModGhpcy5jb25maWcpLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gcmVzdWx0LkFjY291bnQ7XG4gICAgICBjb25zdCBwYXJ0aXRpb24gPSByZXN1bHQuQXJuIS5zcGxpdCgnOicpWzFdO1xuICAgICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVFMgZGlkblxcJ3QgcmV0dXJuIGFuIGFjY291bnQgSUQnKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdEZWZhdWx0IGFjY291bnQgSUQ6JywgYWNjb3VudElkKTtcbiAgICAgIHJldHVybiB7IGFjY291bnRJZCwgcGFydGl0aW9uIH07XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBEb24ndCB1c2UgLS0gb25seSB1c2VkIHRvIHdyaXRlIHRlc3RzIGFyb3VuZCBhc3N1bWluZyByb2xlcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjdXJyZW50Q3JlZGVudGlhbHMoKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICBhd2FpdCB0aGlzLmNyZWRlbnRpYWxzLmdldFByb21pc2UoKTtcbiAgICByZXR1cm4gdGhpcy5jcmVkZW50aWFscztcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhIHdyYXBwaW5nIG9iamVjdCBmb3IgdGhlIHVuZGVybHlpbmcgc2VydmljZSBvYmplY3RcbiAqXG4gKiBSZXNwb25kcyB0byBmYWlsdXJlcyBpbiB0aGUgdW5kZXJseWluZyBzZXJ2aWNlIGNhbGxzLCBpbiB0d28gZGlmZmVyZW50XG4gKiB3YXlzOlxuICpcbiAqIC0gV2hlbiBlcnJvcnMgYXJlIGVuY291bnRlcmVkLCBsb2cgdGhlIGZhaWxpbmcgY2FsbCBhbmQgdGhlIGVycm9yIHRoYXRcbiAqICAgaXQgdHJpZ2dlcmVkIChhdCBkZWJ1ZyBsZXZlbCkuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGxhY2sgb2ZcbiAqICAgc3RhY2sgdHJhY2VzIGluIE5vZGVKUyBvdGhlcndpc2UgbWFrZXMgaXQgdmVyeSBoYXJkIHRvIHN1c3Mgb3V0IHdoZXJlXG4gKiAgIGEgY2VydGFpbiBBV1MgZXJyb3Igb2NjdXJyZWQuXG4gKiAtIFRoZSBKUyBTREsgaGFzIGEgZnVubnkgYnVzaW5lc3Mgb2Ygd3JhcHBpbmcgYW55IGNyZWRlbnRpYWwtYmFzZWQgZXJyb3JcbiAqICAgaW4gYSBzdXBlci1nZW5lcmljIChhbmQgaW4gb3VyIGNhc2Ugd3JvbmcpIGV4Y2VwdGlvbi4gSWYgd2UgdGhlbiB1c2UgYVxuICogICAnQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMnIGFuZCB0aGUgdGFyZ2V0IHJvbGUgZG9lc24ndCBleGlzdCxcbiAqICAgdGhlIGVycm9yIG1lc3NhZ2UgdGhhdCBzaG93cyB1cCBieSBkZWZhdWx0IGlzIHN1cGVyIG1pc2xlYWRpbmdcbiAqICAgKGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMzI3MikuIFdlIGNhbiBmaXggdGhpcyBiZWNhdXNlXG4gKiAgIHRoZSBleGNlcHRpb24gY29udGFpbnMgdGhlIFwiaW5uZXIgZXhjZXB0aW9uXCIsIHNvIHdlIHVud3JhcCBhbmQgdGhyb3dcbiAqICAgdGhlIGNvcnJlY3QgZXJyb3IgKFwiY2Fubm90IGFzc3VtZSByb2xlXCIpLlxuICpcbiAqIFRoZSB3cmFwcGluZyBidXNpbmVzcyBiZWxvdyBpcyBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIHRoYW4geW91J2QgdGhpbmtcbiAqIGJlY2F1c2Ugd2UgbXVzdCBob29rIGludG8gdGhlIGBwcm9taXNlKClgIG1ldGhvZCBvZiB0aGUgb2JqZWN0IHRoYXQncyBiZWluZ1xuICogcmV0dXJuZWQgZnJvbSB0aGUgbWV0aG9kcyBvZiB0aGUgb2JqZWN0IHRoYXQgd2Ugd3JhcCwgc28gdGhlcmUncyB0d29cbiAqIGxldmVscyBvZiB3cmFwcGluZyBnb2luZyBvbiwgYW5kIGFsc28gc29tZSBleGNlcHRpb25zIHRvIHRoZSB3cmFwcGluZyBtYWdpYy5cbiAqL1xuZnVuY3Rpb24gd3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nPEEgZXh0ZW5kcyBvYmplY3Q+KHNlcnZpY2VPYmplY3Q6IEEpOiBBIHtcbiAgY29uc3QgY2xhc3NPYmplY3QgPSBzZXJ2aWNlT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICByZXR1cm4gbmV3IFByb3h5KHNlcnZpY2VPYmplY3QsIHtcbiAgICBnZXQob2JqOiBBLCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHJlYWwgPSAob2JqIGFzIGFueSlbcHJvcF07XG4gICAgICAvLyBUaGluZ3Mgd2UgZG9uJ3Qgd2FudCB0byBpbnRlcmNlcHQ6XG4gICAgICAvLyAtIEFueXRoaW5nIHRoYXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgIC8vIC0gJ2NvbnN0cnVjdG9yJywgczMudXBsb2FkKCkgd2lsbCB1c2UgdGhpcyB0byBkbyBzb21lIG1hZ2ljIGFuZCB3ZSBuZWVkIHRoZSB1bmRlcmx5aW5nIGNvbnN0cnVjdG9yLlxuICAgICAgLy8gLSBBbnkgbWV0aG9kIHRoYXQncyBub3Qgb24gdGhlIHNlcnZpY2UgY2xhc3MgKGRvIG5vdCBpbnRlcmNlcHQgJ21ha2VSZXF1ZXN0JyBhbmQgb3RoZXIgaGVscGVycykuXG4gICAgICBpZiAocHJvcCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhY2xhc3NPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzRnVuY3Rpb24ocmVhbCkpIHsgcmV0dXJuIHJlYWw7IH1cblxuICAgICAgLy8gTk9URTogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24oKSBhbmQgbm90IGFuICgpID0+IHtcbiAgICAgIC8vIGJlY2F1c2UgSSBuZWVkICd0aGlzJyB0byBiZSBkeW5hbWljYWxseSBib3VuZCBhbmQgbm90IHN0YXRpY2FsbHkgYm91bmQuXG4gICAgICAvLyBJZiB5b3VyIGxpbnRlciBjb21wbGFpbnMgZG9uJ3QgbGlzdGVuIHRvIGl0IVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRoaXM6IGFueSkge1xuICAgICAgICAvLyBDYWxsIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uLiBJZiBpdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgcHJvbWlzZSgpXG4gICAgICAgIC8vIG1ldGhvZCBvbiBpdCwgd3JhcCB0aGF0ICdwcm9taXNlJyBtZXRob2QuXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVhbC5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAvLyBEb24ndCBpbnRlcmNlcHQgdW5sZXNzIHRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYSAnLnByb21pc2UoKScgbWV0aG9kLlxuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fCAhcmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlOyB9XG4gICAgICAgIGlmICghKCdwcm9taXNlJyBpbiByZXNwb25zZSkpIHsgcmV0dXJuIHJlc3BvbnNlOyB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9taXNlIG1ldGhvZCByZXBsYWNlZCB3aXRoIGEgd3JhcHBlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGRvIGFkZGl0aW9uYWwgdGhpbmdzIHRvIGVycm9ycy5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShyZXNwb25zZSksIHtcbiAgICAgICAgICBwcm9taXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnByb21pc2UoKS5jYXRjaCgoZTogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgZSA9IG1ha2VEZXRhaWxlZEV4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgICAgZGVidWcoYENhbGwgZmFpbGVkOiAke3Byb3B9KCR7SlNPTi5zdHJpbmdpZnkoYXJnc1swXSl9KSA9PiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyAvLyBSZS0ndGhyb3cnIHRoZSBuZXcgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICB9KTtcbn1cblxuY29uc3QgQ1VSUkVOVF9BQ0NPVU5UX0tFWSA9IFN5bWJvbCgnY3VycmVudF9hY2NvdW50X2tleScpO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHg6IGFueSk6IHggaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkge1xuICByZXR1cm4geCAmJiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBtb3JlIGRldGFpbGVkIGVycm9yIG91dCBvZiBhIGdlbmVyaWMgZXJyb3IgaWYgd2UgY2FuXG4gKi9cbmZ1bmN0aW9uIG1ha2VEZXRhaWxlZEV4Y2VwdGlvbihlOiBFcnJvcik6IEVycm9yIHtcbiAgLy8gVGhpcyBpcyB0aGUgc3VwZXItZ2VuZXJpYyBcInNvbWV0aGluZydzIHdyb25nXCIgZXJyb3IgdGhhdCB0aGUgSlMgU0RLIHdyYXBzIG90aGVyIGVycm9ycyBpbi5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2Jsb2IvZjBhYzJlNTM0NTdjNzUxMjg4M2QwNjc3MDEzZWFjYWFkNmNkOGExOS9saWIvZXZlbnRfbGlzdGVuZXJzLmpzI0w4NFxuICBpZiAodHlwZW9mIGUubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnJykpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IChlIGFzIGFueSkub3JpZ2luYWxFcnJvcjtcbiAgICBpZiAob3JpZ2luYWwpIHtcbiAgICAgIC8vIFdoZW4gdGhlIFNESyBkb2VzIGEgJ3V0aWwuY29weScsIHRoZXkgbG9zZSB0aGUgRXJyb3ItbmVzcyBvZiB0aGUgaW5uZXIgZXJyb3JcbiAgICAgIC8vICh0aGV5IGNvcHkgdGhlIEVycm9yJ3MgcHJvcGVydGllcyBpbnRvIGEgcGxhaW4gb2JqZWN0KSBzbyBtYWtlIGl0IGFuIEVycm9yIG9iamVjdCBhZ2Fpbi5cbiAgICAgIGUgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigpLCBvcmlnaW5hbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGVycm9yIG1pZ2h0IHN0aWxsIGJlIGEgZ2VuZXJpYyBcIkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIGZhaWxlZFwiXG4gIC8vIGVycm9yIHdoaWNoIHdyYXBzIHRoZSBSRUFMIGVycm9yIChBc3N1bWVSb2xlIGZhaWxlZCkuIFdlJ3JlIGdvaW5nIHRvIHJlcGxhY2UgdGhlIGVycm9yXG4gIC8vIG1lc3NhZ2Ugd2l0aCBvbmUgdGhhdCdzIG1vcmUgbGlrZWx5IHRvIGhlbHAgdXNlcnMsIGFuZCB0ZWxsIHRoZW0gdGhlIG1vc3QgcHJvYmFibGVcbiAgLy8gZml4IChib290c3RyYXBwaW5nKS4gVGhlIHVuZGVybHlpbmcgc2VydmljZSBjYWxsIGZhaWx1cmUgd2lsbCBiZSBhcHBlbmRlZCBiZWxvdy5cbiAgaWYgKGUubWVzc2FnZSA9PT0gJ0NvdWxkIG5vdCBsb2FkIGNyZWRlbnRpYWxzIGZyb20gQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMnKSB7XG4gICAgZS5tZXNzYWdlID0gJ0NvdWxkIG5vdCBhc3N1bWUgcm9sZSBpbiB0YXJnZXQgYWNjb3VudCAoZGlkIHlvdSBib290c3RyYXAgdGhlIGVudmlyb25tZW50IHdpdGggdGhlIHJpZ2h0IFxcJy0tdHJ1c3RcXCdzPyknO1xuICB9XG5cbiAgLy8gUmVwbGFjZSB0aGUgbWVzc2FnZSBvbiB0aGlzIGVycm9yIHdpdGggYSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbm5lciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gTXVzdCBtb3JlIGNsZWFyIHdoYXQncyBnb2luZyBvbiB0aGF0IHdheS5cbiAgZS5tZXNzYWdlID0gYWxsQ2hhaW5lZEV4Y2VwdGlvbk1lc3NhZ2VzKGUpO1xuICByZXR1cm4gZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbmNhdGVuYXRlZCBtZXNzYWdlIG9mIGFsbCBleGNlcHRpb25zIGluIHRoZSBBV1MgZXhjZXB0aW9uIGNoYWluXG4gKi9cbmZ1bmN0aW9uIGFsbENoYWluZWRFeGNlcHRpb25NZXNzYWdlcyhlOiBFcnJvciB8IHVuZGVmaW5lZCkge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICB3aGlsZSAoZSkge1xuICAgIHJldC5wdXNoKGUubWVzc2FnZSk7XG4gICAgZSA9IChlIGFzIGFueSkub3JpZ2luYWxFcnJvcjtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJzogJyk7XG59XG4iXX0=