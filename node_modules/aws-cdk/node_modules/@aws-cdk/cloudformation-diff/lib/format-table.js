"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatTable = void 0;
const colors = require("colors/safe");
const stringWidth = require("string-width");
const table = require("table");
/**
 * Render a two-dimensional array to a visually attractive table
 *
 * First row is considered the table header.
 */
function formatTable(cells, columns) {
    return table.table(cells, {
        border: TABLE_BORDER_CHARACTERS,
        columns: buildColumnConfig(columns !== undefined ? calculcateColumnWidths(cells, columns) : undefined),
        drawHorizontalLine: (line) => {
            // Numbering like this: [line 0] [header = row[0]] [line 1] [row 1] [line 2] [content 2] [line 3]
            return (line < 2 || line === cells.length) || lineBetween(cells[line - 1], cells[line]);
        },
    }).trimRight();
}
exports.formatTable = formatTable;
/**
 * Whether we should draw a line between two rows
 *
 * Draw horizontal line if 2nd column values are different.
 */
function lineBetween(rowA, rowB) {
    return rowA[1] !== rowB[1];
}
function buildColumnConfig(widths) {
    if (widths === undefined) {
        return undefined;
    }
    const ret = {};
    widths.forEach((width, i) => {
        ret[i] = { width, useWordWrap: true }; // 'useWordWrap' is not in @types/table
        if (width === undefined) {
            delete ret[i].width;
        }
    });
    return ret;
}
/**
 * Calculate column widths given a terminal width
 *
 * We do this by calculating a fair share for every column. Extra width smaller
 * than the fair share is evenly distributed over all columns that exceed their
 * fair share.
 */
function calculcateColumnWidths(rows, terminalWidth) {
    // The terminal is sometimes reported to be 0. Also if the terminal is VERY narrow,
    // just assume a reasonable minimum size.
    terminalWidth = Math.max(terminalWidth, 40);
    // use 'string-width' to not count ANSI chars as actual character width
    const columns = rows[0].map((_, i) => Math.max(...rows.map(row => stringWidth(String(row[i])))));
    // If we have no terminal width, do nothing
    const contentWidth = terminalWidth - 2 - columns.length * 3;
    // If we don't exceed the terminal width, do nothing
    if (sum(columns) <= contentWidth) {
        return columns;
    }
    const fairShare = Math.min(contentWidth / columns.length);
    const smallColumns = columns.filter(w => w < fairShare);
    let distributableWidth = contentWidth - sum(smallColumns);
    const fairDistributable = Math.floor(distributableWidth / (columns.length - smallColumns.length));
    const ret = new Array();
    for (const requestedWidth of columns) {
        if (requestedWidth < fairShare) {
            // Small column gets what they want
            ret.push(requestedWidth);
        }
        else {
            // Last column gets all remaining, otherwise get fair redist share
            const width = distributableWidth < 2 * fairDistributable ? distributableWidth : fairDistributable;
            ret.push(width);
            distributableWidth -= width;
        }
    }
    return ret;
}
function sum(xs) {
    let total = 0;
    for (const x of xs) {
        total += x;
    }
    return total;
}
// What color the table is going to be
const tableColor = colors.gray;
// Unicode table characters with a color
const TABLE_BORDER_CHARACTERS = {
    topBody: tableColor('─'),
    topJoin: tableColor('┬'),
    topLeft: tableColor('┌'),
    topRight: tableColor('┐'),
    bottomBody: tableColor('─'),
    bottomJoin: tableColor('┴'),
    bottomLeft: tableColor('└'),
    bottomRight: tableColor('┘'),
    bodyLeft: tableColor('│'),
    bodyRight: tableColor('│'),
    bodyJoin: tableColor('│'),
    joinBody: tableColor('─'),
    joinLeft: tableColor('├'),
    joinRight: tableColor('┤'),
    joinJoin: tableColor('┼'),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LXRhYmxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZm9ybWF0LXRhYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQUFzQztBQUN0Qyw0Q0FBNEM7QUFDNUMsK0JBQStCO0FBRS9COzs7O0dBSUc7QUFDSCxTQUFnQixXQUFXLENBQUMsS0FBaUIsRUFBRSxPQUEyQjtJQUN4RSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFO1FBQ3hCLE1BQU0sRUFBRSx1QkFBdUI7UUFDL0IsT0FBTyxFQUFFLGlCQUFpQixDQUFDLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ3RHLGtCQUFrQixFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDM0IsaUdBQWlHO1lBQ2pHLE9BQU8sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksS0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUYsQ0FBQztLQUNGLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNqQixDQUFDO0FBVEQsa0NBU0M7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxXQUFXLENBQUMsSUFBYyxFQUFFLElBQWM7SUFDakQsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUFDLE1BQTRCO0lBQ3JELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtRQUFFLE9BQU8sU0FBUyxDQUFDO0tBQUU7SUFFL0MsTUFBTSxHQUFHLEdBQTRDLEVBQUUsQ0FBQztJQUN4RCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzFCLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFTLENBQUMsQ0FBQyx1Q0FBdUM7UUFDckYsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztTQUNyQjtJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxzQkFBc0IsQ0FBQyxJQUFnQixFQUFFLGFBQXFCO0lBQ3JFLG1GQUFtRjtJQUNuRix5Q0FBeUM7SUFDekMsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRTVDLHVFQUF1RTtJQUN2RSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFakcsMkNBQTJDO0lBQzNDLE1BQU0sWUFBWSxHQUFHLGFBQWEsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFFNUQsb0RBQW9EO0lBQ3BELElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFlBQVksRUFBRTtRQUFFLE9BQU8sT0FBTyxDQUFDO0tBQUU7SUFFckQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7SUFFeEQsSUFBSSxrQkFBa0IsR0FBRyxZQUFZLEdBQUcsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzFELE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFFbEcsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUNoQyxLQUFLLE1BQU0sY0FBYyxJQUFJLE9BQU8sRUFBRTtRQUNwQyxJQUFJLGNBQWMsR0FBRyxTQUFTLEVBQUU7WUFDOUIsbUNBQW1DO1lBQ25DLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDMUI7YUFBTTtZQUNMLGtFQUFrRTtZQUNsRSxNQUFNLEtBQUssR0FBRyxrQkFBa0IsR0FBRyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztZQUNsRyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2hCLGtCQUFrQixJQUFJLEtBQUssQ0FBQztTQUM3QjtLQUNGO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsU0FBUyxHQUFHLENBQUMsRUFBWTtJQUN2QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNsQixLQUFLLElBQUksQ0FBQyxDQUFDO0tBQ1o7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxzQ0FBc0M7QUFDdEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztBQUUvQix3Q0FBd0M7QUFDeEMsTUFBTSx1QkFBdUIsR0FBRztJQUM5QixPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN4QixPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN4QixPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN4QixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN6QixVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUMzQixVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUMzQixVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUMzQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUM1QixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN6QixTQUFTLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUMxQixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN6QixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN6QixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUN6QixTQUFTLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUMxQixRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztDQUMxQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9ycy9zYWZlJztcbmltcG9ydCAqIGFzIHN0cmluZ1dpZHRoIGZyb20gJ3N0cmluZy13aWR0aCc7XG5pbXBvcnQgKiBhcyB0YWJsZSBmcm9tICd0YWJsZSc7XG5cbi8qKlxuICogUmVuZGVyIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IHRvIGEgdmlzdWFsbHkgYXR0cmFjdGl2ZSB0YWJsZVxuICpcbiAqIEZpcnN0IHJvdyBpcyBjb25zaWRlcmVkIHRoZSB0YWJsZSBoZWFkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUYWJsZShjZWxsczogc3RyaW5nW11bXSwgY29sdW1uczogbnVtYmVyIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRhYmxlLnRhYmxlKGNlbGxzLCB7XG4gICAgYm9yZGVyOiBUQUJMRV9CT1JERVJfQ0hBUkFDVEVSUyxcbiAgICBjb2x1bW5zOiBidWlsZENvbHVtbkNvbmZpZyhjb2x1bW5zICE9PSB1bmRlZmluZWQgPyBjYWxjdWxjYXRlQ29sdW1uV2lkdGhzKGNlbGxzLCBjb2x1bW5zKSA6IHVuZGVmaW5lZCksXG4gICAgZHJhd0hvcml6b250YWxMaW5lOiAobGluZSkgPT4ge1xuICAgICAgLy8gTnVtYmVyaW5nIGxpa2UgdGhpczogW2xpbmUgMF0gW2hlYWRlciA9IHJvd1swXV0gW2xpbmUgMV0gW3JvdyAxXSBbbGluZSAyXSBbY29udGVudCAyXSBbbGluZSAzXVxuICAgICAgcmV0dXJuIChsaW5lIDwgMiB8fCBsaW5lID09PSBjZWxscy5sZW5ndGgpIHx8IGxpbmVCZXR3ZWVuKGNlbGxzW2xpbmUgLSAxXSwgY2VsbHNbbGluZV0pO1xuICAgIH0sXG4gIH0pLnRyaW1SaWdodCgpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgd2Ugc2hvdWxkIGRyYXcgYSBsaW5lIGJldHdlZW4gdHdvIHJvd3NcbiAqXG4gKiBEcmF3IGhvcml6b250YWwgbGluZSBpZiAybmQgY29sdW1uIHZhbHVlcyBhcmUgZGlmZmVyZW50LlxuICovXG5mdW5jdGlvbiBsaW5lQmV0d2Vlbihyb3dBOiBzdHJpbmdbXSwgcm93Qjogc3RyaW5nW10pIHtcbiAgcmV0dXJuIHJvd0FbMV0gIT09IHJvd0JbMV07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29sdW1uQ29uZmlnKHdpZHRoczogbnVtYmVyW10gfCB1bmRlZmluZWQpOiB7IFtpbmRleDogbnVtYmVyXTogdGFibGUuVGFibGVDb2x1bW5zIH0gfCB1bmRlZmluZWQge1xuICBpZiAod2lkdGhzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIGNvbnN0IHJldDogeyBbaW5kZXg6IG51bWJlcl06IHRhYmxlLlRhYmxlQ29sdW1ucyB9ID0ge307XG4gIHdpZHRocy5mb3JFYWNoKCh3aWR0aCwgaSkgPT4ge1xuICAgIHJldFtpXSA9IHsgd2lkdGgsIHVzZVdvcmRXcmFwOiB0cnVlIH0gYXMgYW55OyAvLyAndXNlV29yZFdyYXAnIGlzIG5vdCBpbiBAdHlwZXMvdGFibGVcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHJldFtpXS53aWR0aDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvbHVtbiB3aWR0aHMgZ2l2ZW4gYSB0ZXJtaW5hbCB3aWR0aFxuICpcbiAqIFdlIGRvIHRoaXMgYnkgY2FsY3VsYXRpbmcgYSBmYWlyIHNoYXJlIGZvciBldmVyeSBjb2x1bW4uIEV4dHJhIHdpZHRoIHNtYWxsZXJcbiAqIHRoYW4gdGhlIGZhaXIgc2hhcmUgaXMgZXZlbmx5IGRpc3RyaWJ1dGVkIG92ZXIgYWxsIGNvbHVtbnMgdGhhdCBleGNlZWQgdGhlaXJcbiAqIGZhaXIgc2hhcmUuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGNhdGVDb2x1bW5XaWR0aHMocm93czogc3RyaW5nW11bXSwgdGVybWluYWxXaWR0aDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAvLyBUaGUgdGVybWluYWwgaXMgc29tZXRpbWVzIHJlcG9ydGVkIHRvIGJlIDAuIEFsc28gaWYgdGhlIHRlcm1pbmFsIGlzIFZFUlkgbmFycm93LFxuICAvLyBqdXN0IGFzc3VtZSBhIHJlYXNvbmFibGUgbWluaW11bSBzaXplLlxuICB0ZXJtaW5hbFdpZHRoID0gTWF0aC5tYXgodGVybWluYWxXaWR0aCwgNDApO1xuXG4gIC8vIHVzZSAnc3RyaW5nLXdpZHRoJyB0byBub3QgY291bnQgQU5TSSBjaGFycyBhcyBhY3R1YWwgY2hhcmFjdGVyIHdpZHRoXG4gIGNvbnN0IGNvbHVtbnMgPSByb3dzWzBdLm1hcCgoXywgaSkgPT4gTWF0aC5tYXgoLi4ucm93cy5tYXAocm93ID0+IHN0cmluZ1dpZHRoKFN0cmluZyhyb3dbaV0pKSkpKTtcblxuICAvLyBJZiB3ZSBoYXZlIG5vIHRlcm1pbmFsIHdpZHRoLCBkbyBub3RoaW5nXG4gIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRlcm1pbmFsV2lkdGggLSAyIC0gY29sdW1ucy5sZW5ndGggKiAzO1xuXG4gIC8vIElmIHdlIGRvbid0IGV4Y2VlZCB0aGUgdGVybWluYWwgd2lkdGgsIGRvIG5vdGhpbmdcbiAgaWYgKHN1bShjb2x1bW5zKSA8PSBjb250ZW50V2lkdGgpIHsgcmV0dXJuIGNvbHVtbnM7IH1cblxuICBjb25zdCBmYWlyU2hhcmUgPSBNYXRoLm1pbihjb250ZW50V2lkdGggLyBjb2x1bW5zLmxlbmd0aCk7XG4gIGNvbnN0IHNtYWxsQ29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKHcgPT4gdyA8IGZhaXJTaGFyZSk7XG5cbiAgbGV0IGRpc3RyaWJ1dGFibGVXaWR0aCA9IGNvbnRlbnRXaWR0aCAtIHN1bShzbWFsbENvbHVtbnMpO1xuICBjb25zdCBmYWlyRGlzdHJpYnV0YWJsZSA9IE1hdGguZmxvb3IoZGlzdHJpYnV0YWJsZVdpZHRoIC8gKGNvbHVtbnMubGVuZ3RoIC0gc21hbGxDb2x1bW5zLmxlbmd0aCkpO1xuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxudW1iZXI+KCk7XG4gIGZvciAoY29uc3QgcmVxdWVzdGVkV2lkdGggb2YgY29sdW1ucykge1xuICAgIGlmIChyZXF1ZXN0ZWRXaWR0aCA8IGZhaXJTaGFyZSkge1xuICAgICAgLy8gU21hbGwgY29sdW1uIGdldHMgd2hhdCB0aGV5IHdhbnRcbiAgICAgIHJldC5wdXNoKHJlcXVlc3RlZFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFzdCBjb2x1bW4gZ2V0cyBhbGwgcmVtYWluaW5nLCBvdGhlcndpc2UgZ2V0IGZhaXIgcmVkaXN0IHNoYXJlXG4gICAgICBjb25zdCB3aWR0aCA9IGRpc3RyaWJ1dGFibGVXaWR0aCA8IDIgKiBmYWlyRGlzdHJpYnV0YWJsZSA/IGRpc3RyaWJ1dGFibGVXaWR0aCA6IGZhaXJEaXN0cmlidXRhYmxlO1xuICAgICAgcmV0LnB1c2god2lkdGgpO1xuICAgICAgZGlzdHJpYnV0YWJsZVdpZHRoIC09IHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN1bSh4czogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGNvbnN0IHggb2YgeHMpIHtcbiAgICB0b3RhbCArPSB4O1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cblxuLy8gV2hhdCBjb2xvciB0aGUgdGFibGUgaXMgZ29pbmcgdG8gYmVcbmNvbnN0IHRhYmxlQ29sb3IgPSBjb2xvcnMuZ3JheTtcblxuLy8gVW5pY29kZSB0YWJsZSBjaGFyYWN0ZXJzIHdpdGggYSBjb2xvclxuY29uc3QgVEFCTEVfQk9SREVSX0NIQVJBQ1RFUlMgPSB7XG4gIHRvcEJvZHk6IHRhYmxlQ29sb3IoJ+KUgCcpLFxuICB0b3BKb2luOiB0YWJsZUNvbG9yKCfilKwnKSxcbiAgdG9wTGVmdDogdGFibGVDb2xvcign4pSMJyksXG4gIHRvcFJpZ2h0OiB0YWJsZUNvbG9yKCfilJAnKSxcbiAgYm90dG9tQm9keTogdGFibGVDb2xvcign4pSAJyksXG4gIGJvdHRvbUpvaW46IHRhYmxlQ29sb3IoJ+KUtCcpLFxuICBib3R0b21MZWZ0OiB0YWJsZUNvbG9yKCfilJQnKSxcbiAgYm90dG9tUmlnaHQ6IHRhYmxlQ29sb3IoJ+KUmCcpLFxuICBib2R5TGVmdDogdGFibGVDb2xvcign4pSCJyksXG4gIGJvZHlSaWdodDogdGFibGVDb2xvcign4pSCJyksXG4gIGJvZHlKb2luOiB0YWJsZUNvbG9yKCfilIInKSxcbiAgam9pbkJvZHk6IHRhYmxlQ29sb3IoJ+KUgCcpLFxuICBqb2luTGVmdDogdGFibGVDb2xvcign4pScJyksXG4gIGpvaW5SaWdodDogdGFibGVDb2xvcign4pSkJyksXG4gIGpvaW5Kb2luOiB0YWJsZUNvbG9yKCfilLwnKSxcbn07XG4iXX0=